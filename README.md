# CANBUS DRIVER

CANBUS Driver reausable on different platforms.

## Supported Hardware

- STM32H745ZIT6U (NUCLEO-H745ZI-Q)
- STM32U575ZIT6Q (NUCLEO-U575ZI-Q)
- STM32L552ZET6Q (NUCLEO-L552ZE-Q)
- STM32G431RBTx  (NUCLEO-G431RB)

### Functions Guide

- `canbus_initialize` : initializes the CANBus.
- `canbus_send` : sends a frame.
- `canbus_send_plain` : sends a plain frame.
- `canbus_callback_add`: adds a callback. 
- `canbus_callback_remove`: removes a callback.
- `canbus_callback_exists`: checks for existing callbacks.

## How to use

- In your main, add the header file `drv_canbus.h`.
- In the `.ioc` file, enable the CAN peripheral.
- In the main, create a `FDCAN_FilterTypeDef` array containing the filters needed. An example of filters configuration:

```C
static FDCAN_FilterTypeDef canbus_filters[]=
{
	{
		.IdType = FDCAN_STANDARD_ID,
		.FilterIndex = 0,
		.FilterType = FDCAN_FILTER_MASK,
		.FilterConfig = FDCAN_FILTER_TO_RXFIFO0,
		.FilterID1 = 0x500,
		.FilterID2 = 0x7ff
	},
	{
		.IdType = FDCAN_EXTENDED_ID,
		.FilterIndex = 0,
		.FilterType = FDCAN_FILTER_MASK,
		.FilterConfig = FDCAN_FILTER_TO_RXFIFO0,
		.FilterID1 = 0x18DA1900,
		.FilterID2 = 0x1FFFFF00
	}
};
```

- Create an instance for `canbus_t`. The following members must be defined:
	- `instance.mx_init` : CAN initializing function generated by the configuration tool.
	- `instance.hcan` : handler of choice (ex. hfdcan1)
	- `instance.filters` : the aforementioned filters array.
	- `instance.filters_cnt`: number of filters.
	- `instance.callbacks` : array of  `canbus_callback_t` instances:
		- `.uint32_t id` : id of the frame that triggers the callback.
		- `.uint32_t mask` : mask to select a set of ids that trigger the callback.
		- `.uint32_t type` : Standard or Extended.
		- `.void (* callback)(canbus_frame_t *)` : pointer to the callback function.
		- Example of callback function: 
		``` C
		void canbus_callback_500(canbus_frame_t *frame)
		{
		x_last_canbus_500 = xTaskGetTickCount();
		receive_dcdc_enabled = frame->dt[0] == 1 ? 1 : 0;
		receive_pack_500 = 1;
		} 
		-struct canbus_callback *next: pointer to the next callback.
		```
- use the functions:
	- `canbus_send`: to send a frame. Frames must be contained in a `canbus_frame_t` structure:
		- `uint32_t id` : CAN Frame Id.
		- `uint32_t id_type`:  CAN Frame Id Type `cbus_id_type`.
		- `uint16_t fr_format`: CAN Frame Format `cbus_fr_format`.
		- `uint16_t dlc` :  Size of data.
		- `uint8_t dt[64]` : Actual data.
	- `canbus_callback_add` : to add a callback to the list. For example:
	```
	canbus_callback_add(&instance, 0x500, 0x0, FDCAN_STANDARD_ID, canbus_callback_500)
	```


## Example

Let's consider a NUCLEO - L552ZE-Q. HFDCAN1 has been enabled in the `.iso` file.

```C
uint8_t data[64] = {0};
canbus_t canbus1 = {.mx_init = MX_FDCAN1_Init, .hcan = &hfdcan1, .filters_cnt = ?, .callbacks = ?};
canbus_frame_t canbus_frame = { .fr_format = CBUS_FR_FRM_STD, .id_type = CBUS_ID_T_STANDARD,.id = 500 ,.dlc = X,.dt = data};
canbus_initialize(&canbus1);
canbus_send(&canbus1, &canbus_frame);
canbus_send_plain(&canbus1, CBUS_FR_FRM_STD, CBUS_ID_T_STANDARD, 500, uint8_t dlc, uint8_t* data);
```